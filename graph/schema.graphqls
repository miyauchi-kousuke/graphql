  """
Specify a query to be read from gql-public. Will use the configured cacheAge on
the query resolve configuration, or the override value passed through the
directive as publicCache(cacheAge: INT) argument.
"""
    directive @publicCache(
    """Optional override for the query-level cacheAge value."""
  cacheAge: Int
              ) on FIELD

              """
Specify a field to only be included in the response if the user is logged in.
"""
              directive @userData on FIELD

              """Represents the state of an activity"""
              enum ActivityState {
              """Activity is created"""
              CREATED

              """Activity is active or in progress"""
              ACTIVE

              """Activity is done"""
              COMPLETED

              """Activity is ready to be started"""
              READY

              """Activity is invalid"""
              INVALID

              """Activity, like a set, has been called to start"""
              CALLED

              """Activity is queued to run"""
              QUEUED
  }

    """A user's address"""
    type Address {
  id: ID
  city: String
  country: String
  countryId: Int
  state: String
  stateId: Int
  }

    """Represents the name of the third-party service (e.g Twitter) for OAuth"""
    enum AuthorizationType {
    TWITTER
    TWITCH
    STEAM
    DISCORD
    MIXER
  }

    """Bracket-specific configuration"""
    interface BracketConfig {
  id: ID
  bracketType: BracketType
  }

    """The type of Bracket format that a Phase is configured with."""
    enum BracketType {
    SINGLE_ELIMINATION
    DOUBLE_ELIMINATION
    ROUND_ROBIN
    SWISS
    EXHIBITION
    CUSTOM_SCHEDULE
    MATCHMAKING
    ELIMINATION_ROUNDS
    RACE
  }

    """Comparison operator"""
    enum Comparator {
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    EQUAL
    LESS_THAN_OR_EQUAL
    LESS_THAN
  }

    """Name, address, etc"""
    type ContactInfo {
  id: ID

        """Participant City Name"""
  city: String

          """Participant Country Name"""
  country: String

             """Participant Country (region) id"""
  countryId: Int
  name: String

          """First Name"""
  nameFirst: String

               """Last Name"""
  nameLast: String

              """Participant State Name"""
  state: String

           """Participant State (region) id"""
  stateId: Int

             """Zip or Postal Code"""
  zipcode: String
  }

    """An entrant in an event"""
    type Entrant {
  id: ID
  event: Event
  isDisqualified: Boolean

                    """
  The entrant name as it appears in bracket: gamerTag of the participant or team name
  """
  name: String
  participants: [Participant]
  seeds: [Seed]
  skill: Int

           """
  Standing for this entrant given an event. All entrants queried must be in the same event (for now).
  """
  standing: Standing
  stream: Streams @deprecated(reason: "DEPRECATED. Use streams instead, which supports multiple stream types and teams.")
  streams: [Streams]
  }

    type EntrantConnection {
  pageInfo: PageInfo
  nodes: [Entrant]
  }

    """An event in a tournament"""
    type Event {
  id: ID

        """How long before the event start will the check-in end (in seconds)"""
  checkInBuffer: Int

                   """How long the event check-in will last (in seconds)"""
  checkInDuration: Int

                     """Whether check-in is enabled for this event"""
  checkInEnabled: Boolean

                    """When the event was created (unix timestamp)"""
  createdAt: Timestamp

               """Last date attendees are able to create teams for team events"""
  deckSubmissionDeadline: Timestamp

                            """Maximum number of participants each Entrant can have"""
  entrantSizeMax: Int

                    """Minimum number of participants each Entrant can have"""
  entrantSizeMin: Int

                    """The entrants that belong to an event, paginated by filter criteria"""
  entrants(query: EventEntrantPageQuery): EntrantConnection

                                            """Whether the event has decks"""
  hasDecks: Boolean

              """Are player tasks enabled for this event"""
  hasTasks: Boolean
  images(type: String): [Image]

                          """Whether the event is an online event or not"""
  isOnline: Boolean

              """Markdown field for match rules/instructions"""
  matchRulesMarkdown: String

                        """Title of event set by organizer"""
  name: String

          """Gets the number of entrants in this event"""
  numEntrants: Int

                 """The phase groups that belong to an event."""
  phaseGroups: [PhaseGroup]

                 """The phases that belong to an event."""
                 phases(
                 """Filter phases by state. If not specified will default to all phases"""
  state: ActivityState

           """Optionally only return results for this phase"""
  phaseId: ID
  ): [Phase]

       """TO settings for prizing"""
  prizingInfo: JSON
  publishing: JSON

                """Markdown field for event rules/instructions"""
  rulesMarkdown: String

                   """Id of the event ruleset"""
  rulesetId: Int

               """Settings pulled from the event ruleset, if one exists"""
  rulesetSettings: JSON @deprecated(reason: "Use ruleset")

                                              """Paginated sets for this Event"""
                                              sets(
  page: Int
  perPage: Int

             """How to sort these sets"""
  sortType: SetSortType

              """Supported filter options to filter down set results."""
  filters: SetFilters
  ): SetConnection
  slug: String

          """Paginated list of standings"""
  standings(query: StandingPaginationQuery!): StandingConnection

                                                """When does this event start?"""
  startAt: Timestamp

             """The state of the Event."""
  state: ActivityState

           """Paginated stations on this event"""
  stations(query: StationFilter): StationsConnection

                                    """Last date attendees are able to create teams for team events"""
  teamManagementDeadline: Timestamp

                            """
  If this is a teams event, returns whether or not teams can set custom names
  """
  teamNameAllowed: Boolean
  tournament: Tournament

                """
  The type of the event, whether an entrant will have one participant or multiple
  """
  type: Int

          """When the event was last modified (unix timestamp)"""
  updatedAt: Timestamp

               """Whether the event uses the new EventSeeds for seeding"""
  useEventSeeds: Boolean
  videogame: Videogame

               """The waves being used by the event"""
               waves(
               """Waves filtered by phaseId, returns all if not set."""
  phaseId: ID
  ): [Wave]
  }

    type EventConnection {
  pageInfo: PageInfo
  nodes: [Event]
  }

    input EventEntrantPageQuery {
  page: Int
  perPage: Int
  sortBy: String
  filter: EventEntrantPageQueryFilter
  }

    input EventEntrantPageQueryFilter {
  name: String
  }

    """Name and Gamertag of the owner of an event in a league"""
    type EventOwner {
  eventId: ID
  email: String
  gamerTag: String
  fullName: String
  }

    type EventOwnerConnection {
  pageInfo: PageInfo
  nodes: [EventOwner]
  }

    input EventOwnersQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  }

    """A game represents a single game within a set."""
    type Game {
  id: ID
  images(type: String): [Image]
  orderNum: Int

              """Selections for this game such as character, etc."""
  selections: [GameSelection]

                """The stage that this game was played on (if applicable)"""
  stage: Stage
  state: Int
  winnerId: Int
  }

    """A selection for this game. i.e. character/stage selection, etc"""
    type GameSelection {
  id: ID

        """The entrant who this selection is for"""
  entrant: Entrant
  orderNum: Int

              """
  The participant who this selection is for. This is only populated if there are
  selections for multiple participants of a single entrant
  """
  participant: Participant
  selectionType: GameSelectionType
  selectionValue: Int
  }

    """The type of selection i.e. is it for a character or something else"""
    enum GameSelectionType {
    """Character selection"""
    CHARACTER
  }

    """An image"""
    type Image {
  id: ID
  height: Float
  ratio: Float
  type: String
  url: String
  width: Float
  }

    """
The `JSON` scalar type represents JSON values as specified by
		[ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
    scalar JSON

    """A league"""
    type League {
  id: ID
  addrState: String
  city: String
  countryCode: String

                 """When the tournament was created (unix timestamp)"""
  createdAt: Timestamp
  currency: String

              """When the tournament ends"""
  endAt: Timestamp
  entrantCount: Int
  eventOwners(query: EventOwnersQuery): EventOwnerConnection

                                          """When does event registration close"""
  eventRegistrationClosesAt: Timestamp

                               """Paginated list of events in a league"""
  events(query: LeagueEventsQuery): EventConnection

                                      """Hacked "progression" into this final event"""
  finalEventId: Int

                  """True if tournament has at least one offline event"""
  hasOfflineEvents: Boolean
  hasOnlineEvents: Boolean
  hashtag: String
  images(type: String): [Image]

                          """True if tournament has at least one online event"""
  isOnline: Boolean
  lat: Float
  links: TournamentLinks
  lng: Float
  mapsPlaceId: String

                 """The tournament name"""
  name: String

          """Top X number of people in the standings who progress to final event"""
  numProgressingToFinalEvent: Int
  numUniquePlayers: Int
  postalCode: String
  primaryContact: String
  primaryContactType: String

                        """Publishing settings for this tournament"""
  publishing: JSON

                """When does registration for the tournament end"""
  registrationClosesAt: Timestamp
  rules: String

           """The short slug used to form the url"""
  shortSlug: String

               """Whether standings for this league should be visible"""
  showStandings: Boolean
  slug: String

          """Paginated list of standings"""
  standings(query: StandingGroupStandingPageFilter): StandingConnection

                                                       """When the tournament Starts"""
  startAt: Timestamp

             """
  State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
  """
  state: Int

           """When is the team creation deadline"""
  teamCreationClosesAt: Timestamp

                          """The timezone of the tournament"""
  timezone: String

              """The type of tournament from TournamentType"""
  tournamentType: Int

                    """When the tournament was last modified (unix timestamp)"""
  updatedAt: Timestamp

               """Build Tournament URL"""
               url(
               """Tournament tab to add to URL"""
  tab: String

         """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
  relative: Boolean = true
  ): String
  venueAddress: String
  venueName: String
  videogames: [Videogame]
  }

    type LeagueConnection {
  pageInfo: PageInfo
  nodes: [League]
  }

    input LeagueEventsFilter {
  tierIds: [ID]
  userId: ID
  upcoming: Boolean
  }

    input LeagueEventsQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: LeagueEventsFilter
  }

    input LocationFilterType {
  countryCode: String
  state: String
  city: String
  }

    """Match-level configuration"""
    interface MatchConfig {
  id: ID
  bracketType: BracketType
  }

    """
Different options available for verifying player-reported match results
"""
    enum MatchConfigVerificationMethod {
    TWITCH
    STREAM_ME
    ANY
    MIXER
    YOUTUBE
  }

    type Mutation {
    """Delete a phase by id"""
  deletePhase(phaseId: ID!): Boolean

                               """Delete a station by id"""
  deleteStation(stationId: ID!): Boolean

                                   """Delete a wave by id"""
  deleteWave(waveId: ID!): Boolean

                             """
  Automatically attempt to resolve all schedule conflicts. Returns a list of changed seeds
  """
  resolveScheduleConflicts(tournamentId: ID!, options: ResolveConflictsOptions): [Seed]

                                           """Swap two seed ids in a phase"""
  swapSeeds(phaseId: ID!, seed1Id: ID!, seed2Id: ID!): [Seed]

                       """Update set of phase groups in a phase"""
  updatePhaseGroups(groupConfigs: [PhaseGroupUpdateInput]!): [PhaseGroup]

                                    """Update the seeding for a phase"""
  updatePhaseSeeding(phaseId: ID!, seedMapping: [UpdatePhaseSeedInfo]!, options: UpdatePhaseSeedingOptions): Phase

                                                  """Create or update a Phase"""
  upsertPhase(phaseId: ID, eventId: ID, payload: PhaseUpsertInput!): Phase

                         """Add or update a station by id"""
  upsertStation(stationId: ID, tournamentId: ID, fields: StationUpsertInput!): Stations

                             """Add or update a wave by id"""
  upsertWave(waveId: ID, tournamentId: ID, fields: WaveUpsertInput!): Wave
  }

    type PageInfo {
  total: Int
  totalPages: Int
  page: Int
  perPage: Int
  sortBy: String
  filter: JSON
  }

    input PaginationSearchType {
  fieldsToSearch: [String]
  searchString: String
  }

    """A participant of a tournament; either a spectator or competitor"""
    type Participant {
  id: ID

        """If this participant was checked-in by admin"""
  checkedIn: Boolean

               """The time this participant was checked-in by admin"""
  checkedInAt: Timestamp

                 """Info for connected accounts to external services."""
  connectedAccounts: JSON

                       """
  Contact Info selected during registration. Falls back to User.location and/or
  User.name if necessary. These fields are for admin use only and do not respect
  user privacy settings. DO NOT display this information publicly.
  """
  contactInfo: ContactInfo

                 """
  Email of the user, only available to admins within 18 months of tournament
  """
  email: String
  entrants: [Entrant]

              """The events this participant registered for."""
  events: [Event]

            """The tag that was used in registration e.g. Mang0"""
  gamerTag: String
  images(type: String): [Image]
  player: Player

            """The prefix that was used in registration e.g. C9"""
  prefix: String

            """The user this participant is associated to."""
  user: User

          """If this participant is verified as actually being in the tournament"""
  verified: Boolean
  }

    type ParticipantConnection {
  pageInfo: PageInfo
  nodes: [Participant]
  }

    input ParticipantPageFilter {
  id: ID
  ids: [ID]
  eventIds: [ID]
  search: ParticipantSearch
  gamerTag: String
  unpaid: Boolean
  incompleteTeam: Boolean
  missingDeck: Boolean
  checkedIn: Boolean
  notCheckedIn: Boolean
  }

    input ParticipantPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: ParticipantPageFilter
  }

    input ParticipantSearch {
    """e.g. gamerTag, prefix"""
  fieldsToSearch: [String]
  searchString: String
  }

    """A phase in an event"""
    type Phase {
  id: ID

        """The bracket type of this phase."""
  bracketType: BracketType

                 """The Event that this phase belongs to"""
  event: Event

           """Number of phase groups in this phase"""
  groupCount: Int

                """Is the phase an exhibition or not."""
  isExhibition: Boolean

                  """Name of phase e.g. Round 1 Pools"""
  name: String

          """The number of seeds this phase contains."""
  numSeeds: Int
  paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds' instead")

                          """Phase groups under this phase, paginated"""
  phaseGroups(query: PhaseGroupPageQuery): PhaseGroupConnection

                                             """The relative order of this phase within an event"""
  phaseOrder: Int

                """Paginated seeds for this phase"""
  seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

                 """Paginated sets for this Phase"""
                 sets(
  page: Int
  perPage: Int

             """How to sort these sets"""
  sortType: SetSortType

              """Supported filter options to filter down set results."""
  filters: SetFilters
  ): SetConnection

       """State of the phase"""
  state: ActivityState
  waves: [Wave]
  }

    """A group within a phase"""
    type PhaseGroup {
  id: ID

        """The bracket type of this group's phase."""
  bracketType: BracketType

                 """Unique identifier for this group within the context of its phase"""
  displayIdentifier: String

                       """
  For the given phase group, this is the start time of the first round that occurs in the group.
  """
  firstRoundTime: Timestamp
  numRounds: Int
  paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds', which is now paginated")

                          """Paginated sets on this phaseGroup"""
                          paginatedSets(
  page: Int
  perPage: Int

             """How to sort these sets"""
  sortType: SetSortType

              """Supported filter options to filter down set results."""
  filters: SetFilters
  ): SetConnection @deprecated(reason: "Please use 'sets', which is now paginated")

                                         """The phase associated with this phase group"""
  phase: Phase

           """The progressions out of this phase group"""
  progressionsOut: [Progression]
  rounds: [Round]
  seedMap: JSON

             """Paginated seeds for this phase group"""
  seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

                 """Paginated sets on this phaseGroup"""
                 sets(
  page: Int
  perPage: Int

             """How to sort these sets"""
  sortType: SetSortType

              """Supported filter options to filter down set results."""
  filters: SetFilters
  ): SetConnection

       """Paginated list of standings"""
  standings(query: StandingGroupStandingPageFilter): StandingConnection

                                                       """
  Unix time the group is scheduled to start. This info could also be on the wave instead.
  """
  startAt: Timestamp
  state: Int
  tiebreakOrder: JSON
  wave: Wave
  }

    type PhaseGroupConnection {
  pageInfo: PageInfo
  nodes: [PhaseGroup]
  }

    input PhaseGroupPageQuery {
  page: Int
  perPage: Int
  sortBy: String
  entrantIds: [ID]
  filter: PhaseGroupPageQueryFilter
  }

    input PhaseGroupPageQueryFilter {
  id: [ID]
  waveId: ID
  }

    input PhaseGroupUpdateInput {
  phaseGroupId: ID!
  stationId: ID
  waveId: ID
  }

    input PhaseUpsertInput {
    """
    The name of the Phase. For example, "Top 8" or "Pools"
    """
  name: String

    """
    The number of pools to configure for the Phase. Only applies to brackets that support pools
    """
  groupCount: Int
  bracketType: BracketType
  }

    """A player"""
    type Player {
  id: ID
  gamerTag: String
  prefix: String

            """Most recent active & published rankings"""
  rankings(limit: Int, videogameId: ID): [PlayerRank]

                    """Recent sets for this player."""
                    recentSets(
                    """Use this to get H2H history between two players"""
  opponentId: ID
  ): [Set] @deprecated(reason: "Use the sets field instead.")

                                 """Set history for this player."""
                                 sets(
  page: Int
  perPage: Int

             """Supported filter options to filter down set results."""
  filters: SetFilters
  ): SetConnection
  user: User
  }

    """A player's ranks"""
    type PlayerRank {
  id: ID

        """The player's placement on the ranking"""
  rank: Int
  title: String
  }

    """An OAuth ProfileAuthorization object"""
    type ProfileAuthorization {
  id: ID

        """
  The username given by the external service (including discriminator if discord)
  """
  externalUsername: String
  stream: Stream

            """
  The name of the external service providing this auth i.e. "twitch"
            """
  type: AuthorizationType
  url: String
  }

    """
    A connection between a placement in an origin phase group to a destination seed.
    """
    type Progression {
  id: ID
  originOrder: Int
  originPhase: Phase
  originPhaseGroup: PhaseGroup
  originPlacement: Int
  }

    type Query {
    """Returns the authenticated user"""
  currentUser: User

                 """Returns an event given its id or slug"""
  event(id: ID, slug: String): Event

              """Returns a league given its id or slug"""
  league(id: ID, slug: String): League

               """Returns a participant given its id"""
  participant(id: ID!, isAdmin: Boolean): Participant

                    """Returns a phase given its id"""
  phase(id: ID): Phase

                   """Returns a phase group given its id"""
  phaseGroup(id: ID): PhaseGroup

                        """Returns a player given an id"""
  player(id: ID!): Player

                     """Returns a phase seed given its id"""
  seed(id: ID): Seed

                  """Returns a set given its id"""
  set(id: ID!): Set

                  """A shop entity"""
  shop(id: ID, slug: String): Shop

             """Returns an stream given its id"""
  stream(id: ID!): Streams

                     """Returns all the stream queues for a given tournament"""
  streamQueue(tournamentId: ID!, includePlayerStreams: Boolean): [StreamQueue]

                              """Returns a tournament given its id or slug"""
  tournament(id: ID, slug: String): Tournament

                   """Paginated, filterable list of tournaments"""
  tournaments(query: TournamentQuery!): TournamentConnection

                                          """Returns a user given a user slug of the form user/abc123, or id"""
  user(id: ID, slug: String): User

             """Returns a videogame given its id"""
  videogame(id: ID): Videogame

                       """Returns paginated list of videogames matching the search criteria."""
  videogames(query: VideogameQuery!): VideogameConnection
  }

    """Race specific bracket configuration"""
    type RaceBracketConfig implements BracketConfig {
  automaticEndTime: Timestamp
  id: ID
  automaticStartTime: Timestamp
  bracketType: BracketType
  goalTargetComparator: Comparator
  goalTargetValue: String
  limitMode: RaceLimitMode
  limitValue: Int
  raceType: RaceType
  }

    """Enforces limits on the amount of allowable Race submissions"""
    enum RaceLimitMode {
    BEST_ALL
    FIRST_ALL
    PLAYTIME
  }

    """Race specific match configuration"""
    type RaceMatchConfig implements MatchConfig {
  id: ID
  bracketType: BracketType

                 """Can players report results?"""
  playerReportingEnabled: Boolean

                            """Accepted methods of verification that players can use"""
  verificationMethods: [MatchConfigVerificationMethod]

                         """Are players required to submit verification of their reported results?"""
  verificationRequired: Boolean
  }

    """Race type"""
    enum RaceType {
    GOALS
    TIMED
  }

    input ResolveConflictsLockedSeedConfig {
  eventId: ID!
  numSeeds: Int!
  }

    input ResolveConflictsOptions {
  lockedSeeds: [ResolveConflictsLockedSeedConfig]
  }

    """A round within a phase group"""
    type Round {
  id: ID

        """
  If applicable, bestOf is the number of games
  									one must win a majority out of to win a set in this round
  """
  bestOf: Int

            """Indicates this round's order in the phase group"""
  number: Int

            """The time that this round is scheduled to start at"""
  startAt: Timestamp
  }

    """
The score that led to this standing being awarded. The meaning of this field can
vary by standing type and is not used for some standing types.
"""
    type Score {
    """
    The name of this score. e.g. "Kills" or "Stocks"
    """
  label: String

    """The raw score value"""
  value: Float

           """
  Like value, but formatted for race format events. Formatted according to the race config for the front end to use.
  """
  displayValue: String
  }

    """A seed for an entrant"""
    type Seed {
  id: ID

        """Map of Participant ID to checked in boolean"""
  checkedInParticipants: JSON
  entrant: Entrant
  groupSeedNum: Int
  isBye: Boolean
  phase: Phase
  phaseGroup: PhaseGroup
  placeholderName: String
  placement: Int

               """The player(s) associated with this seed's entrant"""
  players: [Player]
  progressionSeedId: Int

                       """Source progression information"""
  progressionSource: Progression
  seedNum: Int

             """
  Entrant's win/loss record for this standing. Scores do not include byes.
  """
  setRecordWithoutByes(phaseGroupId: ID!): JSON
                                             standings(
                                             """
    The container of the standing groups to get standings for. If null, will return all standings.
    """
  containerType: String
  ): [Standing]
  }

    type SeedConnection {
  pageInfo: PageInfo
  nodes: [Seed]
  }

    input SeedPageFilter {
  id: ID
  entrantName: String
  checkInState: Int
  phaseGroupId: [ID]
  phaseId: [ID]
  eventId: ID
  search: SeedSearch
  }

    input SeedPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: SeedPageFilter
  }

    input SeedSearch {
  fieldsToSearch: [String]
  searchString: String
  }

    """A set"""
    type Set {
  id: ID

        """The time this set was marked as completed"""
  completedAt: Timestamp

                 """The time this set was created"""
  createdAt: Timestamp
  displayScore(mainEntrantId: ID): String

                                     """Event that this set belongs to."""
  event: Event

           """Full round text of this set."""
  fullRoundText: String
  game(orderNum: Int!): Game
  games: [Game]

           """Whether this set contains a placeholder entrant"""
  hasPlaceholder: Boolean

                    """
  The letters that describe a unique identifier within the pool. Eg. F, AT
  """
  identifier: String
  images(type: String): [Image]
  lPlacement: Int

                """Phase group that this Set belongs to."""
  phaseGroup: PhaseGroup

                """The round number of the set. Negative numbers are losers bracket"""
  round: Int

           """
  Indicates whether the set is in best of or total games mode. This instructs
  which field is used to figure out how many games are in this set.
  """
  setGamesType: Int

                  """
  A possible spot in a set. Use this to get all entrants in a set. Use this for all bracket types (FFA, elimination, etc)
  """
  slots(includeByes: Boolean = false): [SetSlot]
  startedAt: Timestamp
  state: Int

           """Tournament event station for a set"""
  station: Stations

             """Tournament event stream for a set"""
  stream: Streams

            """
  If setGamesType is in total games mode, this defined the number of games in the set.
  """
  totalGames: Int

                """Url of a VOD for this set"""
  vodUrl: String
  wPlacement: Int
  winnerId: Int
  }

    type SetConnection {
  pageInfo: PageInfo
  nodes: [Set]
  }

    """Filter Sets by geographical constraints."""
    input SetFilterLocation {
    """Only return Sets in this state. Only applicable to US states"""
  state: String

           """
  Only return Sets in this country. Expects a valid two-letter country code
  """
  country: String
  distanceFrom: SetFilterLocationDistanceFrom
  }

    """
Only return Sets that are a certain distance away from a specified point
"""
    input SetFilterLocationDistanceFrom {
    """Point at which to perform distance calculation"""
  point: SetFilterLocationDistanceFromPoint

           """Distance from the point to include results in"""
  radius: String
  }

    input SetFilterLocationDistanceFromPoint {
  lat: Float
  lon: Float
  }

    input SetFilters {
    """Only return Sets for these Entrants"""
  entrantIds: [ID]

                """
  Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only, filter by an entrantSize of 1
  """
  entrantSize: [Int]

                 """Only return Sets that have an attached VOD"""
  hasVod: Boolean

            """
  Do not return empty Sets. For example, set this to true to filter out sets that are waiting for progressions.
  """
  hideEmpty: Boolean

               """Return sets that contain a bye"""
  showByes: Boolean

              """
  Only return Sets that are in an Online event. If omitted, Sets for both online and offline Events are returned
  """
  isEventOnline: Boolean

                   """Only return Sets in certain geographical areas."""
  location: SetFilterLocation

              """Only return Sets for these Participants"""
  participantIds: [ID]

                    """Only return Sets in these PhaseGroups"""
  phaseGroupIds: [ID]

                   """Only return Sets in these Phases"""
  phaseIds: [ID]

              """Only return Sets for these Players"""
  playerIds: [ID]

               """Only return Sets for these Rounds"""
  roundNumber: Int

                 """Only returns Sets that are in these states"""
  state: [Int]

           """Only return Sets that are assigned to these Station IDs"""
  stationIds: [ID]

                """Only return Sets that are assigned to these Station numbers"""
  stationNumbers: [Int]
  }

    """
A slot in a set where a seed currently or will eventually exist in order to participate in the set.
"""
    type SetSlot {
  id: ID
  entrant: Entrant

             """Pairs with prereqType, is the ID of the prereq."""
  prereqId: String

              """
  Given a set prereq type, defines the placement required in the origin set to end up in this slot.
  """
  prereqPlacement: Int

                     """Describes where the entity in this slot comes from."""
  prereqType: String
  seed: Seed

          """The index of the slot. Unique per set."""
  slotIndex: Int

               """
  The standing within this set for the seed currently assigned to this slot.
  """
  standing: Standing
  }

    """Different sort type configurations used when displaying multiple sets"""
    enum SetSortType {
    """Sets will not be sorted."""
    NONE

    """
  Sets are sorted in the suggested order that they be called to be played. The order of completed sets is reversed.
  """
    CALL_ORDER

    """
  Sets are sorted by relevancy dependent on the state and progress of the event.
  """
    MAGIC

    """Sets are sorted in the order that they were started."""
    RECENT

    """Deprecated. This is equivalent to CALL_ORDER"""
    STANDARD
  }

    """A shop"""
    type Shop {
  id: ID
  levels(query: ShopLevelsQuery): ShopLevelConnection
  messages(query: ShopOrderMessagesQuery): ShopOrderMessageConnection
  name: String
  slug: String
  url: String
  }

    """A shop level"""
    type ShopLevel {
  id: ID
  currAmount: Float
  description: String
  goalAmount: Float
  images(type: String): [Image]
  name: String
  }

    type ShopLevelConnection {
  pageInfo: PageInfo
  nodes: [ShopLevel]
  }

    input ShopLevelsQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  }

    """The message and player info for a shop order"""
    type ShopOrderMessage {
  id: ID

        """The player's gamertag. Returns null if anonymous message type"""
  gamertag: String

              """The order message"""
  message: String

             """The player's name. Returns null unless name & tag display is selected"""
  name: String

          """The player who left the comment"""
  player: Player

            """The total order amount"""
  total: Float
  }

    type ShopOrderMessageConnection {
  pageInfo: PageInfo
  nodes: [ShopOrderMessage]
  }

    input ShopOrderMessagesQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  }

    """
Represents the name of the third-party social service (e.g Twitter) for OAuth
"""
    enum SocialConnectionType {
    TWITTER
    TWITCH
    DISCORD
    MIXER
  }

    """Video Stage"""
    type Stage {
  id: ID

        """Stage name"""
  name: String
  }

    """A standing indicates the placement of something within a container."""
    type Standing {
    """
    The containing entity that contextualizes this standing. Event standings, for
    example, represent an entrant's standing in the entire event vs. Set standings
    which is an entrant's standing in only a single set within an event.
    """
  container: StandingContainer
  id: ID

    """
    If the entity this standing is assigned to can be resolved into an entrant, this will provide the entrant.
    """
  entrant: Entrant
  isFinal: Boolean

    """
    Metadata that goes along with this standing. Can take on different forms based on standing group type and settings.
    """
  metadata: JSON
  placement: Int

    """The player(s) tied to this standing's entity"""
  player: Player
  standing: Int @deprecated(reason: "The \"placement\" field is identical and will eventually replace \"standing\"")
  stats: StandingStats
  }

    type StandingConnection {
  pageInfo: PageInfo
  nodes: [Standing]
  }

    """The containing entity that this standing is for"""
    union StandingContainer = Tournament | Event | PhaseGroup | Set

    input StandingGroupStandingPageFilter {
  page: Int
  perPage: Int
  sortBy: String
  }

    input StandingPageFilter {
  id: ID
  ids: [ID]
  search: PaginationSearchType
  }

    input StandingPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: StandingPageFilter
  }

    """
Any stats related to this standing. This type is experimental and very likely to change in the future.
"""
    type StandingStats {
  score: Score
  }

    input StationFilter {
  page: Int
  perPage: Int
  }

    """Stations, such as a stream setup, at an event"""
    type Stations {
  id: ID
  canAutoAssign: Boolean
  clusterNumber: String
  clusterPrefix: Int
  enabled: Boolean
  identifier: Int
  numSetups: Int
  number: Int
  prefix: String
  queue: JSON
  queueDepth: Int
  state: Int
  updatedAt: Timestamp
  }

    type StationsConnection {
  pageInfo: PageInfo
  nodes: [Stations]
  }

    input StationUpsertInput {
  number: Int!
  clusterId: ID
  }

    """A Stream object"""
    type Stream {
  id: ID

        """Whether the stream is currently live. May be slightly delayed."""
  isOnline: Boolean

              """The name of the stream"""
  name: String

          """
  The name of the external service providing this auth i.e. "twitch"
          """
  type: StreamType
  }

    """A Stream queue object"""
    type StreamQueue {
  id: String

        """The sets on the stream"""
  sets: [Set]

          """The stream on the queue"""
  stream: Streams
  }

    """Tournament Stream"""
    type Streams {
  id: ID
  enabled: Boolean
  followerCount: Int
  isOnline: Boolean
  numSetups: Int
  parentStreamId: Int
  streamGame: String
  streamId: String
  streamLogo: String
  streamName: String
  streamSource: StreamSource
  streamStatus: String
  streamType: Int
  streamTypeId: Int
  }

    """Represents the source of a stream"""
    enum StreamSource {
    """Stream is on twitch.tv channel"""
    TWITCH

    """Stream is on smashcast.tv channel"""
    HITBOX

    """Stream is on a stream.me channel"""
    STREAMME

    """Stream is on a mixer.com channel"""
    MIXER
  }

    """Represents the type of stream service"""
    enum StreamType {
    TWITCH
    MIXER
  }

    """A team, usually within the context of an event"""
    type Team {
  id: ID
  entrant: Entrant
  event: Event
  name: String
  }

    type TeamConnection {
  pageInfo: PageInfo
  nodes: [Team]
  }

    input TeamsPageFilter {
  id: ID
  eventId: ID
  tournamentId: ID
  eventIds: [ID]
  incompleteTeam: Boolean
  search: JSON
  }

    input TeamsPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: TeamsPageFilter
  }

    """
Represents a Unix Timestamp. Supports up to 53 bit int values,
		as that is JavaScript's internal memory allocation for integer values.
"""
    scalar Timestamp

    input TopGameFilter {
    """
    Array of which # top game you want to filter on.e.g. [2, 3] will filter on the 2nd and 3rd top games
    """
  gameNums: [Int]
  }

    """A tournament"""
    type Tournament {
  id: ID
  addrState: String

               """Admin-only view of admins for this tournament"""
               admins(
               """Which roles to show"""
  roles: [String]
  ): [User]
  city: String
  countryCode: String

                 """When the tournament was created (unix timestamp)"""
  createdAt: Timestamp
  currency: String

              """When the tournament ends"""
  endAt: Timestamp

           """When does event registration close"""
  eventRegistrationClosesAt: Timestamp
  events(limit: Int): [Event]

                        """True if tournament has at least one offline event"""
  hasOfflineEvents: Boolean
  hasOnlineEvents: Boolean
  hashtag: String
  images(type: String): [Image]

                          """True if tournament has at least one online event"""
  isOnline: Boolean

              """Is tournament registration open"""
  isRegistrationOpen: Boolean
  lat: Float
  links: TournamentLinks
  lng: Float
  mapsPlaceId: String

                 """The tournament name"""
  name: String

          """Number of attendees including spectators, if public"""
  numAttendees: Int

                  """The user who created the tournament"""
  owner: User

           """Paginated, queryable list of participants"""
  participants(query: ParticipantPaginationQuery!, isAdmin: Boolean): ParticipantConnection
  postalCode: String
  primaryContact: String
  primaryContactType: String

                        """Publishing settings for this tournament"""
  publishing: JSON

                """When does registration for the tournament end"""
  registrationClosesAt: Timestamp
  rules: String

           """The short slug used to form the url"""
  shortSlug: String

               """The slug used to form the url"""
  slug: String

          """When the tournament Starts"""
  startAt: Timestamp

             """
  State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
  """
  state: Int
  stations(page: Int, perPage: Int): StationsConnection
  streamQueue: [StreamQueue]
  streams: [Streams]

             """When is the team creation deadline"""
  teamCreationClosesAt: Timestamp

                          """Paginated, queryable list of teams"""
  teams(query: TeamsPaginationQuery!): TeamConnection

                                         """The timezone of the tournament"""
  timezone: String

              """The type of tournament from TournamentType"""
  tournamentType: Int

                    """When the tournament was last modified (unix timestamp)"""
  updatedAt: Timestamp

               """Build Tournament URL"""
               url(
               """Tournament tab to add to URL"""
  tab: String

         """
    Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
    """
  relative: Boolean = true
  ): String
  venueAddress: String
  venueName: String

               """List of all waves in this tournament"""
  waves: [Wave]
  }

    type TournamentConnection {
  pageInfo: PageInfo
  nodes: [Tournament]
  }

    type TournamentLinks {
  facebook: String
  discord: String
  }

    input TournamentLocationFilter {
    """Latitude, Longitude"""
  distanceFrom: String

                  """e.g. 50mi"""
  distance: String
  }

    input TournamentPageFilter {
  id: ID
  ids: [ID]

         """ID of the user that owns this tournament."""
  ownerId: ID
  countryCode: String
  addrState: String
  location: TournamentLocationFilter
  afterDate: Timestamp
  beforeDate: Timestamp
  computedUpdatedAt: Timestamp
  name: String
  venueName: String
  isFeatured: Boolean
  isLeague: Boolean
  hasBannerImages: Boolean
  activeShops: Boolean
  regOpen: Boolean
  past: Boolean
  published: Boolean
  staffPicks: Boolean
  hasOnlineEvents: Boolean
  topGames: TopGameFilter
  upcoming: Boolean
  videogameIds: [ID]
  }

    enum TournamentPaginationSort {
    startAt
    endAt
    eventRegistrationClosesAt
    computedUpdatedAt
    }

    input TournamentQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: TournamentPageFilter
  sort: TournamentPaginationSort
  }

    input UpdatePhaseSeedInfo {
  seedId: ID!
  seedNum: ID!
  phaseGroupId: ID
  }

    input UpdatePhaseSeedingOptions {
    """
    Validate that seedMapping exactly accounts for all entrants in the phase
    """
  strictMode: Boolean
  }

    """A user"""
    type User {
  id: ID

        """Authorizations to external services (i.e. Twitch, Twitter)"""
  authorizations(types: [SocialConnectionType]): [ProfileAuthorization]
  bio: String

         """Public facing user birthday that respects user publishing settings"""
  birthday: String

              """Events this user has competed in"""
  events(query: UserEventsPaginationQuery): EventConnection
  genderPronoun: String
  images(type: String): [Image]

                          """Leagues this user has competed in"""
  leagues(query: UserLeaguesPaginationQuery): LeagueConnection

                                                """Public location info for this user"""
  location: Address

              """Public facing user name that respects user publishing settings"""
  name: String

          """player for user"""
  player: Player
  slug: String

          """Tournaments this user is organizing or competing in"""
  tournaments(query: UserTournamentsPaginationQuery): TournamentConnection
  }

    input UserEventsPaginationFilter {
  videogameId: [ID]
  eventType: Int
  minEntrantCount: Int
  maxEntrantCount: Int
  location: LocationFilterType
  search: PaginationSearchType
  }

    input UserEventsPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: UserEventsPaginationFilter
  }

    input UserLeaguesPaginationFilter {
  videogameId: [ID]
  upcoming: Boolean
  past: Boolean
  search: PaginationSearchType
  }

    input UserLeaguesPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: UserLeaguesPaginationFilter
  }

    input UserTournamentsPaginationFilter {
  past: Boolean
  upcoming: Boolean
  search: PaginationSearchType
  videogameId: [ID]
  tournamentView: String
  }

    input UserTournamentsPaginationQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: UserTournamentsPaginationFilter
  }

    """A videogame"""
    type Videogame {
  id: ID
  displayName: String
  images(type: String): [Image]
  name: String
  slug: String
  }

    type VideogameConnection {
  pageInfo: PageInfo
  nodes: [Videogame]
  }

    input VideogamePageFilter {
  id: [ID]
  name: String
  forUser: ID
  }

    input VideogameQuery {
  page: Int = 1
  perPage: Int = 25
  sortBy: String
  filter: VideogamePageFilter
  }

    """A wave in a tournament"""
    type Wave {
  id: ID

        """The Wave Identifier"""
  identifier: String

                """Unix time the wave is scheduled to start."""
  startAt: Timestamp
  }

    input WaveUpsertInput {
  identifier: String!
  startAt: Timestamp!
  endAt: Timestamp!
  }

