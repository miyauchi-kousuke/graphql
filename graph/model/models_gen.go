// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// Bracket-specific configuration
type BracketConfig interface {
	IsBracketConfig()
}

// Match-level configuration
type MatchConfig interface {
	IsMatchConfig()
}

// The containing entity that this standing is for
type StandingContainer interface {
	IsStandingContainer()
}

// A user's address
type Address struct {
	ID        *string `json:"id"`
	City      *string `json:"city"`
	Country   *string `json:"country"`
	CountryID *int    `json:"countryId"`
	State     *string `json:"state"`
	StateID   *int    `json:"stateId"`
}

// Name, address, etc
type ContactInfo struct {
	ID *string `json:"id"`
	// Participant City Name
	City *string `json:"city"`
	// Participant Country Name
	Country *string `json:"country"`
	// Participant Country (region) id
	CountryID *int    `json:"countryId"`
	Name      *string `json:"name"`
	// First Name
	NameFirst *string `json:"nameFirst"`
	// Last Name
	NameLast *string `json:"nameLast"`
	// Participant State Name
	State *string `json:"state"`
	// Participant State (region) id
	StateID *int `json:"stateId"`
	// Zip or Postal Code
	Zipcode *string `json:"zipcode"`
}

// An entrant in an event
type Entrant struct {
	ID             *string `json:"id"`
	Event          *Event  `json:"event"`
	IsDisqualified *bool   `json:"isDisqualified"`
	// The entrant name as it appears in bracket: gamerTag of the participant or team name
	Name         *string        `json:"name"`
	Participants []*Participant `json:"participants"`
	Seeds        []*Seed        `json:"seeds"`
	Skill        *int           `json:"skill"`
	// Standing for this entrant given an event. All entrants queried must be in the same event (for now).
	Standing *Standing  `json:"standing"`
	Stream   *Streams   `json:"stream"`
	Streams  []*Streams `json:"streams"`
}

type EntrantConnection struct {
	PageInfo *PageInfo  `json:"pageInfo"`
	Nodes    []*Entrant `json:"nodes"`
}

// An event in a tournament
type Event struct {
	ID *string `json:"id"`
	// How long before the event start will the check-in end (in seconds)
	CheckInBuffer *int `json:"checkInBuffer"`
	// How long the event check-in will last (in seconds)
	CheckInDuration *int `json:"checkInDuration"`
	// Whether check-in is enabled for this event
	CheckInEnabled *bool `json:"checkInEnabled"`
	// When the event was created (unix timestamp)
	CreatedAt *string `json:"createdAt"`
	// Last date attendees are able to create teams for team events
	DeckSubmissionDeadline *string `json:"deckSubmissionDeadline"`
	// Maximum number of participants each Entrant can have
	EntrantSizeMax *int `json:"entrantSizeMax"`
	// Minimum number of participants each Entrant can have
	EntrantSizeMin *int `json:"entrantSizeMin"`
	// The entrants that belong to an event, paginated by filter criteria
	Entrants *EntrantConnection `json:"entrants"`
	// Whether the event has decks
	HasDecks *bool `json:"hasDecks"`
	// Are player tasks enabled for this event
	HasTasks *bool    `json:"hasTasks"`
	Images   []*Image `json:"images"`
	// Whether the event is an online event or not
	IsOnline *bool `json:"isOnline"`
	// Markdown field for match rules/instructions
	MatchRulesMarkdown *string `json:"matchRulesMarkdown"`
	// Title of event set by organizer
	Name *string `json:"name"`
	// Gets the number of entrants in this event
	NumEntrants *int `json:"numEntrants"`
	// The phase groups that belong to an event.
	PhaseGroups []*PhaseGroup `json:"phaseGroups"`
	// The phases that belong to an event.
	Phases []*Phase `json:"phases"`
	// TO settings for prizing
	PrizingInfo *string `json:"prizingInfo"`
	Publishing  *string `json:"publishing"`
	// Markdown field for event rules/instructions
	RulesMarkdown *string `json:"rulesMarkdown"`
	// Id of the event ruleset
	RulesetID *int `json:"rulesetId"`
	// Settings pulled from the event ruleset, if one exists
	RulesetSettings *string `json:"rulesetSettings"`
	// Paginated sets for this Event
	Sets *SetConnection `json:"sets"`
	Slug *string        `json:"slug"`
	// Paginated list of standings
	Standings *StandingConnection `json:"standings"`
	// When does this event start?
	StartAt *string `json:"startAt"`
	// The state of the Event.
	State *ActivityState `json:"state"`
	// Paginated stations on this event
	Stations *StationsConnection `json:"stations"`
	// Last date attendees are able to create teams for team events
	TeamManagementDeadline *string `json:"teamManagementDeadline"`
	// If this is a teams event, returns whether or not teams can set custom names
	TeamNameAllowed *bool       `json:"teamNameAllowed"`
	Tournament      *Tournament `json:"tournament"`
	// The type of the event, whether an entrant will have one participant or multiple
	Type *int `json:"type"`
	// When the event was last modified (unix timestamp)
	UpdatedAt *string `json:"updatedAt"`
	// Whether the event uses the new EventSeeds for seeding
	UseEventSeeds *bool      `json:"useEventSeeds"`
	Videogame     *Videogame `json:"videogame"`
	// The waves being used by the event
	Waves []*Wave `json:"waves"`
}

func (Event) IsStandingContainer() {}

type EventConnection struct {
	PageInfo *PageInfo `json:"pageInfo"`
	Nodes    []*Event  `json:"nodes"`
}

type EventEntrantPageQuery struct {
	Page    *int                         `json:"page"`
	PerPage *int                         `json:"perPage"`
	SortBy  *string                      `json:"sortBy"`
	Filter  *EventEntrantPageQueryFilter `json:"filter"`
}

type EventEntrantPageQueryFilter struct {
	Name *string `json:"name"`
}

// Name and Gamertag of the owner of an event in a league
type EventOwner struct {
	EventID  *string `json:"eventId"`
	Email    *string `json:"email"`
	GamerTag *string `json:"gamerTag"`
	FullName *string `json:"fullName"`
}

type EventOwnerConnection struct {
	PageInfo *PageInfo     `json:"pageInfo"`
	Nodes    []*EventOwner `json:"nodes"`
}

type EventOwnersQuery struct {
	Page    *int    `json:"page"`
	PerPage *int    `json:"perPage"`
	SortBy  *string `json:"sortBy"`
}

// A game represents a single game within a set.
type Game struct {
	ID       *string  `json:"id"`
	Images   []*Image `json:"images"`
	OrderNum *int     `json:"orderNum"`
	// Selections for this game such as character, etc.
	Selections []*GameSelection `json:"selections"`
	// The stage that this game was played on (if applicable)
	Stage    *Stage `json:"stage"`
	State    *int   `json:"state"`
	WinnerID *int   `json:"winnerId"`
}

// A selection for this game. i.e. character/stage selection, etc
type GameSelection struct {
	ID *string `json:"id"`
	// The entrant who this selection is for
	Entrant  *Entrant `json:"entrant"`
	OrderNum *int     `json:"orderNum"`
	// The participant who this selection is for. This is only populated if there are
	// selections for multiple participants of a single entrant
	Participant    *Participant       `json:"participant"`
	SelectionType  *GameSelectionType `json:"selectionType"`
	SelectionValue *int               `json:"selectionValue"`
}

// An image
type Image struct {
	ID     *string  `json:"id"`
	Height *float64 `json:"height"`
	Ratio  *float64 `json:"ratio"`
	Type   *string  `json:"type"`
	URL    *string  `json:"url"`
	Width  *float64 `json:"width"`
}

// A league
type League struct {
	ID          *string `json:"id"`
	AddrState   *string `json:"addrState"`
	City        *string `json:"city"`
	CountryCode *string `json:"countryCode"`
	// When the tournament was created (unix timestamp)
	CreatedAt *string `json:"createdAt"`
	Currency  *string `json:"currency"`
	// When the tournament ends
	EndAt        *string               `json:"endAt"`
	EntrantCount *int                  `json:"entrantCount"`
	EventOwners  *EventOwnerConnection `json:"eventOwners"`
	// When does event registration close
	EventRegistrationClosesAt *string `json:"eventRegistrationClosesAt"`
	// Paginated list of events in a league
	Events *EventConnection `json:"events"`
	// Hacked "progression" into this final event
	FinalEventID *int `json:"finalEventId"`
	// True if tournament has at least one offline event
	HasOfflineEvents *bool    `json:"hasOfflineEvents"`
	HasOnlineEvents  *bool    `json:"hasOnlineEvents"`
	Hashtag          *string  `json:"hashtag"`
	Images           []*Image `json:"images"`
	// True if tournament has at least one online event
	IsOnline    *bool            `json:"isOnline"`
	Lat         *float64         `json:"lat"`
	Links       *TournamentLinks `json:"links"`
	Lng         *float64         `json:"lng"`
	MapsPlaceID *string          `json:"mapsPlaceId"`
	// The tournament name
	Name *string `json:"name"`
	// Top X number of people in the standings who progress to final event
	NumProgressingToFinalEvent *int    `json:"numProgressingToFinalEvent"`
	NumUniquePlayers           *int    `json:"numUniquePlayers"`
	PostalCode                 *string `json:"postalCode"`
	PrimaryContact             *string `json:"primaryContact"`
	PrimaryContactType         *string `json:"primaryContactType"`
	// Publishing settings for this tournament
	Publishing *string `json:"publishing"`
	// When does registration for the tournament end
	RegistrationClosesAt *string `json:"registrationClosesAt"`
	Rules                *string `json:"rules"`
	// The short slug used to form the url
	ShortSlug *string `json:"shortSlug"`
	// Whether standings for this league should be visible
	ShowStandings *bool   `json:"showStandings"`
	Slug          *string `json:"slug"`
	// Paginated list of standings
	Standings *StandingConnection `json:"standings"`
	// When the tournament Starts
	StartAt *string `json:"startAt"`
	// State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
	State *int `json:"state"`
	// When is the team creation deadline
	TeamCreationClosesAt *string `json:"teamCreationClosesAt"`
	// The timezone of the tournament
	Timezone *string `json:"timezone"`
	// The type of tournament from TournamentType
	TournamentType *int `json:"tournamentType"`
	// When the tournament was last modified (unix timestamp)
	UpdatedAt *string `json:"updatedAt"`
	// Build Tournament URL
	URL          *string      `json:"url"`
	VenueAddress *string      `json:"venueAddress"`
	VenueName    *string      `json:"venueName"`
	Videogames   []*Videogame `json:"videogames"`
}

type LeagueConnection struct {
	PageInfo *PageInfo `json:"pageInfo"`
	Nodes    []*League `json:"nodes"`
}

type LeagueEventsFilter struct {
	TierIds  []*string `json:"tierIds"`
	UserID   *string   `json:"userId"`
	Upcoming *bool     `json:"upcoming"`
}

type LeagueEventsQuery struct {
	Page    *int                `json:"page"`
	PerPage *int                `json:"perPage"`
	SortBy  *string             `json:"sortBy"`
	Filter  *LeagueEventsFilter `json:"filter"`
}

type LocationFilterType struct {
	CountryCode *string `json:"countryCode"`
	State       *string `json:"state"`
	City        *string `json:"city"`
}

type PageInfo struct {
	Total      *int    `json:"total"`
	TotalPages *int    `json:"totalPages"`
	Page       *int    `json:"page"`
	PerPage    *int    `json:"perPage"`
	SortBy     *string `json:"sortBy"`
	Filter     *string `json:"filter"`
}

type PaginationSearchType struct {
	FieldsToSearch []*string `json:"fieldsToSearch"`
	SearchString   *string   `json:"searchString"`
}

// A participant of a tournament; either a spectator or competitor
type Participant struct {
	ID *string `json:"id"`
	// If this participant was checked-in by admin
	CheckedIn *bool `json:"checkedIn"`
	// The time this participant was checked-in by admin
	CheckedInAt *string `json:"checkedInAt"`
	// Info for connected accounts to external services.
	ConnectedAccounts *string `json:"connectedAccounts"`
	// Contact Info selected during registration. Falls back to User.location and/or
	// User.name if necessary. These fields are for admin use only and do not respect
	// user privacy settings. DO NOT display this information publicly.
	ContactInfo *ContactInfo `json:"contactInfo"`
	// Email of the user, only available to admins within 18 months of tournament
	Email    *string    `json:"email"`
	Entrants []*Entrant `json:"entrants"`
	// The events this participant registered for.
	Events []*Event `json:"events"`
	// The tag that was used in registration e.g. Mang0
	GamerTag *string  `json:"gamerTag"`
	Images   []*Image `json:"images"`
	Player   *Player  `json:"player"`
	// The prefix that was used in registration e.g. C9
	Prefix *string `json:"prefix"`
	// The user this participant is associated to.
	User *User `json:"user"`
	// If this participant is verified as actually being in the tournament
	Verified *bool `json:"verified"`
}

type ParticipantConnection struct {
	PageInfo *PageInfo      `json:"pageInfo"`
	Nodes    []*Participant `json:"nodes"`
}

type ParticipantPageFilter struct {
	ID             *string            `json:"id"`
	Ids            []*string          `json:"ids"`
	EventIds       []*string          `json:"eventIds"`
	Search         *ParticipantSearch `json:"search"`
	GamerTag       *string            `json:"gamerTag"`
	Unpaid         *bool              `json:"unpaid"`
	IncompleteTeam *bool              `json:"incompleteTeam"`
	MissingDeck    *bool              `json:"missingDeck"`
	CheckedIn      *bool              `json:"checkedIn"`
	NotCheckedIn   *bool              `json:"notCheckedIn"`
}

type ParticipantPaginationQuery struct {
	Page    *int                   `json:"page"`
	PerPage *int                   `json:"perPage"`
	SortBy  *string                `json:"sortBy"`
	Filter  *ParticipantPageFilter `json:"filter"`
}

type ParticipantSearch struct {
	// e.g. gamerTag, prefix
	FieldsToSearch []*string `json:"fieldsToSearch"`
	SearchString   *string   `json:"searchString"`
}

// A phase in an event
type Phase struct {
	ID *string `json:"id"`
	// The bracket type of this phase.
	BracketType *BracketType `json:"bracketType"`
	// The Event that this phase belongs to
	Event *Event `json:"event"`
	// Number of phase groups in this phase
	GroupCount *int `json:"groupCount"`
	// Is the phase an exhibition or not.
	IsExhibition *bool `json:"isExhibition"`
	// Name of phase e.g. Round 1 Pools
	Name *string `json:"name"`
	// The number of seeds this phase contains.
	NumSeeds       *int            `json:"numSeeds"`
	PaginatedSeeds *SeedConnection `json:"paginatedSeeds"`
	// Phase groups under this phase, paginated
	PhaseGroups *PhaseGroupConnection `json:"phaseGroups"`
	// The relative order of this phase within an event
	PhaseOrder *int `json:"phaseOrder"`
	// Paginated seeds for this phase
	Seeds *SeedConnection `json:"seeds"`
	// Paginated sets for this Phase
	Sets *SetConnection `json:"sets"`
	// State of the phase
	State *ActivityState `json:"state"`
	Waves []*Wave        `json:"waves"`
}

// A group within a phase
type PhaseGroup struct {
	ID *string `json:"id"`
	// The bracket type of this group's phase.
	BracketType *BracketType `json:"bracketType"`
	// Unique identifier for this group within the context of its phase
	DisplayIdentifier *string `json:"displayIdentifier"`
	// For the given phase group, this is the start time of the first round that occurs in the group.
	FirstRoundTime *string         `json:"firstRoundTime"`
	NumRounds      *int            `json:"numRounds"`
	PaginatedSeeds *SeedConnection `json:"paginatedSeeds"`
	// Paginated sets on this phaseGroup
	PaginatedSets *SetConnection `json:"paginatedSets"`
	// The phase associated with this phase group
	Phase *Phase `json:"phase"`
	// The progressions out of this phase group
	ProgressionsOut []*Progression `json:"progressionsOut"`
	Rounds          []*Round       `json:"rounds"`
	SeedMap         *string        `json:"seedMap"`
	// Paginated seeds for this phase group
	Seeds *SeedConnection `json:"seeds"`
	// Paginated sets on this phaseGroup
	Sets *SetConnection `json:"sets"`
	// Paginated list of standings
	Standings *StandingConnection `json:"standings"`
	// Unix time the group is scheduled to start. This info could also be on the wave instead.
	StartAt       *string `json:"startAt"`
	State         *int    `json:"state"`
	TiebreakOrder *string `json:"tiebreakOrder"`
	Wave          *Wave   `json:"wave"`
}

func (PhaseGroup) IsStandingContainer() {}

type PhaseGroupConnection struct {
	PageInfo *PageInfo     `json:"pageInfo"`
	Nodes    []*PhaseGroup `json:"nodes"`
}

type PhaseGroupPageQuery struct {
	Page       *int                       `json:"page"`
	PerPage    *int                       `json:"perPage"`
	SortBy     *string                    `json:"sortBy"`
	EntrantIds []*string                  `json:"entrantIds"`
	Filter     *PhaseGroupPageQueryFilter `json:"filter"`
}

type PhaseGroupPageQueryFilter struct {
	ID     []*string `json:"id"`
	WaveID *string   `json:"waveId"`
}

type PhaseGroupUpdateInput struct {
	PhaseGroupID string  `json:"phaseGroupId"`
	StationID    *string `json:"stationId"`
	WaveID       *string `json:"waveId"`
}

type PhaseUpsertInput struct {
	// The name of the Phase. For example, "Top 8" or "Pools"
	Name *string `json:"name"`
	// The number of pools to configure for the Phase. Only applies to brackets that support pools
	GroupCount  *int         `json:"groupCount"`
	BracketType *BracketType `json:"bracketType"`
}

// A player
type Player struct {
	ID       *string `json:"id"`
	GamerTag *string `json:"gamerTag"`
	Prefix   *string `json:"prefix"`
	// Most recent active & published rankings
	Rankings []*PlayerRank `json:"rankings"`
	// Recent sets for this player.
	RecentSets []*Set `json:"recentSets"`
	// Set history for this player.
	Sets *SetConnection `json:"sets"`
	User *User          `json:"user"`
}

// A player's ranks
type PlayerRank struct {
	ID *string `json:"id"`
	// The player's placement on the ranking
	Rank  *int    `json:"rank"`
	Title *string `json:"title"`
}

// An OAuth ProfileAuthorization object
type ProfileAuthorization struct {
	ID *string `json:"id"`
	// The username given by the external service (including discriminator if discord)
	ExternalUsername *string `json:"externalUsername"`
	Stream           *Stream `json:"stream"`
	// The name of the external service providing this auth i.e. "twitch"
	Type *AuthorizationType `json:"type"`
	URL  *string            `json:"url"`
}

// A connection between a placement in an origin phase group to a destination seed.
type Progression struct {
	ID               *string     `json:"id"`
	OriginOrder      *int        `json:"originOrder"`
	OriginPhase      *Phase      `json:"originPhase"`
	OriginPhaseGroup *PhaseGroup `json:"originPhaseGroup"`
	OriginPlacement  *int        `json:"originPlacement"`
}

// Race specific bracket configuration
type RaceBracketConfig struct {
	AutomaticEndTime     *string        `json:"automaticEndTime"`
	ID                   *string        `json:"id"`
	AutomaticStartTime   *string        `json:"automaticStartTime"`
	BracketType          *BracketType   `json:"bracketType"`
	GoalTargetComparator *Comparator    `json:"goalTargetComparator"`
	GoalTargetValue      *string        `json:"goalTargetValue"`
	LimitMode            *RaceLimitMode `json:"limitMode"`
	LimitValue           *int           `json:"limitValue"`
	RaceType             *RaceType      `json:"raceType"`
}

func (RaceBracketConfig) IsBracketConfig() {}

// Race specific match configuration
type RaceMatchConfig struct {
	ID          *string      `json:"id"`
	BracketType *BracketType `json:"bracketType"`
	// Can players report results?
	PlayerReportingEnabled *bool `json:"playerReportingEnabled"`
	// Accepted methods of verification that players can use
	VerificationMethods []*MatchConfigVerificationMethod `json:"verificationMethods"`
	// Are players required to submit verification of their reported results?
	VerificationRequired *bool `json:"verificationRequired"`
}

func (RaceMatchConfig) IsMatchConfig() {}

type ResolveConflictsLockedSeedConfig struct {
	EventID  string `json:"eventId"`
	NumSeeds int    `json:"numSeeds"`
}

type ResolveConflictsOptions struct {
	LockedSeeds []*ResolveConflictsLockedSeedConfig `json:"lockedSeeds"`
}

// A round within a phase group
type Round struct {
	ID *string `json:"id"`
	// If applicable, bestOf is the number of games
	// 									one must win a majority out of to win a set in this round
	BestOf *int `json:"bestOf"`
	// Indicates this round's order in the phase group
	Number *int `json:"number"`
	// The time that this round is scheduled to start at
	StartAt *string `json:"startAt"`
}

// The score that led to this standing being awarded. The meaning of this field can
// vary by standing type and is not used for some standing types.
type Score struct {
	// The name of this score. e.g. "Kills" or "Stocks"
	Label *string `json:"label"`
	// The raw score value
	Value *float64 `json:"value"`
	// Like value, but formatted for race format events. Formatted according to the race config for the front end to use.
	DisplayValue *string `json:"displayValue"`
}

// A seed for an entrant
type Seed struct {
	ID *string `json:"id"`
	// Map of Participant ID to checked in boolean
	CheckedInParticipants *string     `json:"checkedInParticipants"`
	Entrant               *Entrant    `json:"entrant"`
	GroupSeedNum          *int        `json:"groupSeedNum"`
	IsBye                 *bool       `json:"isBye"`
	Phase                 *Phase      `json:"phase"`
	PhaseGroup            *PhaseGroup `json:"phaseGroup"`
	PlaceholderName       *string     `json:"placeholderName"`
	Placement             *int        `json:"placement"`
	// The player(s) associated with this seed's entrant
	Players           []*Player `json:"players"`
	ProgressionSeedID *int      `json:"progressionSeedId"`
	// Source progression information
	ProgressionSource *Progression `json:"progressionSource"`
	SeedNum           *int         `json:"seedNum"`
	// Entrant's win/loss record for this standing. Scores do not include byes.
	SetRecordWithoutByes *string     `json:"setRecordWithoutByes"`
	Standings            []*Standing `json:"standings"`
}

type SeedConnection struct {
	PageInfo *PageInfo `json:"pageInfo"`
	Nodes    []*Seed   `json:"nodes"`
}

type SeedPageFilter struct {
	ID           *string     `json:"id"`
	EntrantName  *string     `json:"entrantName"`
	CheckInState *int        `json:"checkInState"`
	PhaseGroupID []*string   `json:"phaseGroupId"`
	PhaseID      []*string   `json:"phaseId"`
	EventID      *string     `json:"eventId"`
	Search       *SeedSearch `json:"search"`
}

type SeedPaginationQuery struct {
	Page    *int            `json:"page"`
	PerPage *int            `json:"perPage"`
	SortBy  *string         `json:"sortBy"`
	Filter  *SeedPageFilter `json:"filter"`
}

type SeedSearch struct {
	FieldsToSearch []*string `json:"fieldsToSearch"`
	SearchString   *string   `json:"searchString"`
}

// A set
type Set struct {
	ID *string `json:"id"`
	// The time this set was marked as completed
	CompletedAt *string `json:"completedAt"`
	// The time this set was created
	CreatedAt    *string `json:"createdAt"`
	DisplayScore *string `json:"displayScore"`
	// Event that this set belongs to.
	Event *Event `json:"event"`
	// Full round text of this set.
	FullRoundText *string `json:"fullRoundText"`
	Game          *Game   `json:"game"`
	Games         []*Game `json:"games"`
	// Whether this set contains a placeholder entrant
	HasPlaceholder *bool `json:"hasPlaceholder"`
	// The letters that describe a unique identifier within the pool. Eg. F, AT
	Identifier *string  `json:"identifier"`
	Images     []*Image `json:"images"`
	LPlacement *int     `json:"lPlacement"`
	// Phase group that this Set belongs to.
	PhaseGroup *PhaseGroup `json:"phaseGroup"`
	// The round number of the set. Negative numbers are losers bracket
	Round *int `json:"round"`
	// Indicates whether the set is in best of or total games mode. This instructs
	// which field is used to figure out how many games are in this set.
	SetGamesType *int `json:"setGamesType"`
	// A possible spot in a set. Use this to get all entrants in a set. Use this for all bracket types (FFA, elimination, etc)
	Slots     []*SetSlot `json:"slots"`
	StartedAt *string    `json:"startedAt"`
	State     *int       `json:"state"`
	// Tournament event station for a set
	Station *Stations `json:"station"`
	// Tournament event stream for a set
	Stream *Streams `json:"stream"`
	// If setGamesType is in total games mode, this defined the number of games in the set.
	TotalGames *int `json:"totalGames"`
	// Url of a VOD for this set
	VodURL     *string `json:"vodUrl"`
	WPlacement *int    `json:"wPlacement"`
	WinnerID   *int    `json:"winnerId"`
}

func (Set) IsStandingContainer() {}

type SetConnection struct {
	PageInfo *PageInfo `json:"pageInfo"`
	Nodes    []*Set    `json:"nodes"`
}

// Filter Sets by geographical constraints.
type SetFilterLocation struct {
	// Only return Sets in this state. Only applicable to US states
	State *string `json:"state"`
	// Only return Sets in this country. Expects a valid two-letter country code
	Country      *string                        `json:"country"`
	DistanceFrom *SetFilterLocationDistanceFrom `json:"distanceFrom"`
}

// Only return Sets that are a certain distance away from a specified point
type SetFilterLocationDistanceFrom struct {
	// Point at which to perform distance calculation
	Point *SetFilterLocationDistanceFromPoint `json:"point"`
	// Distance from the point to include results in
	Radius *string `json:"radius"`
}

type SetFilterLocationDistanceFromPoint struct {
	Lat *float64 `json:"lat"`
	Lon *float64 `json:"lon"`
}

type SetFilters struct {
	// Only return Sets for these Entrants
	EntrantIds []*string `json:"entrantIds"`
	// Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only, filter by an entrantSize of 1
	EntrantSize []*int `json:"entrantSize"`
	// Only return Sets that have an attached VOD
	HasVod *bool `json:"hasVod"`
	// Do not return empty Sets. For example, set this to true to filter out sets that are waiting for progressions.
	HideEmpty *bool `json:"hideEmpty"`
	// Return sets that contain a bye
	ShowByes *bool `json:"showByes"`
	// Only return Sets that are in an Online event. If omitted, Sets for both online and offline Events are returned
	IsEventOnline *bool `json:"isEventOnline"`
	// Only return Sets in certain geographical areas.
	Location *SetFilterLocation `json:"location"`
	// Only return Sets for these Participants
	ParticipantIds []*string `json:"participantIds"`
	// Only return Sets in these PhaseGroups
	PhaseGroupIds []*string `json:"phaseGroupIds"`
	// Only return Sets in these Phases
	PhaseIds []*string `json:"phaseIds"`
	// Only return Sets for these Players
	PlayerIds []*string `json:"playerIds"`
	// Only return Sets for these Rounds
	RoundNumber *int `json:"roundNumber"`
	// Only returns Sets that are in these states
	State []*int `json:"state"`
	// Only return Sets that are assigned to these Station IDs
	StationIds []*string `json:"stationIds"`
	// Only return Sets that are assigned to these Station numbers
	StationNumbers []*int `json:"stationNumbers"`
}

// A slot in a set where a seed currently or will eventually exist in order to participate in the set.
type SetSlot struct {
	ID      *string  `json:"id"`
	Entrant *Entrant `json:"entrant"`
	// Pairs with prereqType, is the ID of the prereq.
	PrereqID *string `json:"prereqId"`
	// Given a set prereq type, defines the placement required in the origin set to end up in this slot.
	PrereqPlacement *int `json:"prereqPlacement"`
	// Describes where the entity in this slot comes from.
	PrereqType *string `json:"prereqType"`
	Seed       *Seed   `json:"seed"`
	// The index of the slot. Unique per set.
	SlotIndex *int `json:"slotIndex"`
	// The standing within this set for the seed currently assigned to this slot.
	Standing *Standing `json:"standing"`
}

// A shop
type Shop struct {
	ID       *string                     `json:"id"`
	Levels   *ShopLevelConnection        `json:"levels"`
	Messages *ShopOrderMessageConnection `json:"messages"`
	Name     *string                     `json:"name"`
	Slug     *string                     `json:"slug"`
	URL      *string                     `json:"url"`
}

// A shop level
type ShopLevel struct {
	ID          *string  `json:"id"`
	CurrAmount  *float64 `json:"currAmount"`
	Description *string  `json:"description"`
	GoalAmount  *float64 `json:"goalAmount"`
	Images      []*Image `json:"images"`
	Name        *string  `json:"name"`
}

type ShopLevelConnection struct {
	PageInfo *PageInfo    `json:"pageInfo"`
	Nodes    []*ShopLevel `json:"nodes"`
}

type ShopLevelsQuery struct {
	Page    *int    `json:"page"`
	PerPage *int    `json:"perPage"`
	SortBy  *string `json:"sortBy"`
}

// The message and player info for a shop order
type ShopOrderMessage struct {
	ID *string `json:"id"`
	// The player's gamertag. Returns null if anonymous message type
	Gamertag *string `json:"gamertag"`
	// The order message
	Message *string `json:"message"`
	// The player's name. Returns null unless name & tag display is selected
	Name *string `json:"name"`
	// The player who left the comment
	Player *Player `json:"player"`
	// The total order amount
	Total *float64 `json:"total"`
}

type ShopOrderMessageConnection struct {
	PageInfo *PageInfo           `json:"pageInfo"`
	Nodes    []*ShopOrderMessage `json:"nodes"`
}

type ShopOrderMessagesQuery struct {
	Page    *int    `json:"page"`
	PerPage *int    `json:"perPage"`
	SortBy  *string `json:"sortBy"`
}

// Video Stage
type Stage struct {
	ID *string `json:"id"`
	// Stage name
	Name *string `json:"name"`
}

// A standing indicates the placement of something within a container.
type Standing struct {
	// The containing entity that contextualizes this standing. Event standings, for
	// example, represent an entrant's standing in the entire event vs. Set standings
	// which is an entrant's standing in only a single set within an event.
	Container StandingContainer `json:"container"`
	ID        *string           `json:"id"`
	// If the entity this standing is assigned to can be resolved into an entrant, this will provide the entrant.
	Entrant *Entrant `json:"entrant"`
	IsFinal *bool    `json:"isFinal"`
	// Metadata that goes along with this standing. Can take on different forms based on standing group type and settings.
	Metadata  *string `json:"metadata"`
	Placement *int    `json:"placement"`
	// The player(s) tied to this standing's entity
	Player   *Player        `json:"player"`
	Standing *int           `json:"standing"`
	Stats    *StandingStats `json:"stats"`
}

type StandingConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Nodes    []*Standing `json:"nodes"`
}

type StandingGroupStandingPageFilter struct {
	Page    *int    `json:"page"`
	PerPage *int    `json:"perPage"`
	SortBy  *string `json:"sortBy"`
}

type StandingPageFilter struct {
	ID     *string               `json:"id"`
	Ids    []*string             `json:"ids"`
	Search *PaginationSearchType `json:"search"`
}

type StandingPaginationQuery struct {
	Page    *int                `json:"page"`
	PerPage *int                `json:"perPage"`
	SortBy  *string             `json:"sortBy"`
	Filter  *StandingPageFilter `json:"filter"`
}

// Any stats related to this standing. This type is experimental and very likely to change in the future.
type StandingStats struct {
	Score *Score `json:"score"`
}

type StationFilter struct {
	Page    *int `json:"page"`
	PerPage *int `json:"perPage"`
}

type StationUpsertInput struct {
	Number    int     `json:"number"`
	ClusterID *string `json:"clusterId"`
}

// Stations, such as a stream setup, at an event
type Stations struct {
	ID            *string `json:"id"`
	CanAutoAssign *bool   `json:"canAutoAssign"`
	ClusterNumber *string `json:"clusterNumber"`
	ClusterPrefix *int    `json:"clusterPrefix"`
	Enabled       *bool   `json:"enabled"`
	Identifier    *int    `json:"identifier"`
	NumSetups     *int    `json:"numSetups"`
	Number        *int    `json:"number"`
	Prefix        *string `json:"prefix"`
	Queue         *string `json:"queue"`
	QueueDepth    *int    `json:"queueDepth"`
	State         *int    `json:"state"`
	UpdatedAt     *string `json:"updatedAt"`
}

type StationsConnection struct {
	PageInfo *PageInfo   `json:"pageInfo"`
	Nodes    []*Stations `json:"nodes"`
}

// A Stream object
type Stream struct {
	ID *string `json:"id"`
	// Whether the stream is currently live. May be slightly delayed.
	IsOnline *bool `json:"isOnline"`
	// The name of the stream
	Name *string `json:"name"`
	// The name of the external service providing this auth i.e. "twitch"
	Type *StreamType `json:"type"`
}

// A Stream queue object
type StreamQueue struct {
	ID *string `json:"id"`
	// The sets on the stream
	Sets []*Set `json:"sets"`
	// The stream on the queue
	Stream *Streams `json:"stream"`
}

// Tournament Stream
type Streams struct {
	ID             *string       `json:"id"`
	Enabled        *bool         `json:"enabled"`
	FollowerCount  *int          `json:"followerCount"`
	IsOnline       *bool         `json:"isOnline"`
	NumSetups      *int          `json:"numSetups"`
	ParentStreamID *int          `json:"parentStreamId"`
	StreamGame     *string       `json:"streamGame"`
	StreamID       *string       `json:"streamId"`
	StreamLogo     *string       `json:"streamLogo"`
	StreamName     *string       `json:"streamName"`
	StreamSource   *StreamSource `json:"streamSource"`
	StreamStatus   *string       `json:"streamStatus"`
	StreamType     *int          `json:"streamType"`
	StreamTypeID   *int          `json:"streamTypeId"`
}

// A team, usually within the context of an event
type Team struct {
	ID      *string  `json:"id"`
	Entrant *Entrant `json:"entrant"`
	Event   *Event   `json:"event"`
	Name    *string  `json:"name"`
}

type TeamConnection struct {
	PageInfo *PageInfo `json:"pageInfo"`
	Nodes    []*Team   `json:"nodes"`
}

type TeamsPageFilter struct {
	ID             *string   `json:"id"`
	EventID        *string   `json:"eventId"`
	TournamentID   *string   `json:"tournamentId"`
	EventIds       []*string `json:"eventIds"`
	IncompleteTeam *bool     `json:"incompleteTeam"`
	Search         *string   `json:"search"`
}

type TeamsPaginationQuery struct {
	Page    *int             `json:"page"`
	PerPage *int             `json:"perPage"`
	SortBy  *string          `json:"sortBy"`
	Filter  *TeamsPageFilter `json:"filter"`
}

type TopGameFilter struct {
	// Array of which # top game you want to filter on.e.g. [2, 3] will filter on the 2nd and 3rd top games
	GameNums []*int `json:"gameNums"`
}

// A tournament
type Tournament struct {
	ID        *string `json:"id"`
	AddrState *string `json:"addrState"`
	// Admin-only view of admins for this tournament
	Admins      []*User `json:"admins"`
	City        *string `json:"city"`
	CountryCode *string `json:"countryCode"`
	// When the tournament was created (unix timestamp)
	CreatedAt *string `json:"createdAt"`
	Currency  *string `json:"currency"`
	// When the tournament ends
	EndAt *string `json:"endAt"`
	// When does event registration close
	EventRegistrationClosesAt *string  `json:"eventRegistrationClosesAt"`
	Events                    []*Event `json:"events"`
	// True if tournament has at least one offline event
	HasOfflineEvents *bool    `json:"hasOfflineEvents"`
	HasOnlineEvents  *bool    `json:"hasOnlineEvents"`
	Hashtag          *string  `json:"hashtag"`
	Images           []*Image `json:"images"`
	// True if tournament has at least one online event
	IsOnline *bool `json:"isOnline"`
	// Is tournament registration open
	IsRegistrationOpen *bool            `json:"isRegistrationOpen"`
	Lat                *float64         `json:"lat"`
	Links              *TournamentLinks `json:"links"`
	Lng                *float64         `json:"lng"`
	MapsPlaceID        *string          `json:"mapsPlaceId"`
	// The tournament name
	Name *string `json:"name"`
	// Number of attendees including spectators, if public
	NumAttendees *int `json:"numAttendees"`
	// The user who created the tournament
	Owner *User `json:"owner"`
	// Paginated, queryable list of participants
	Participants       *ParticipantConnection `json:"participants"`
	PostalCode         *string                `json:"postalCode"`
	PrimaryContact     *string                `json:"primaryContact"`
	PrimaryContactType *string                `json:"primaryContactType"`
	// Publishing settings for this tournament
	Publishing *string `json:"publishing"`
	// When does registration for the tournament end
	RegistrationClosesAt *string `json:"registrationClosesAt"`
	Rules                *string `json:"rules"`
	// The short slug used to form the url
	ShortSlug *string `json:"shortSlug"`
	// The slug used to form the url
	Slug *string `json:"slug"`
	// When the tournament Starts
	StartAt *string `json:"startAt"`
	// State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
	State       *int                `json:"state"`
	Stations    *StationsConnection `json:"stations"`
	StreamQueue []*StreamQueue      `json:"streamQueue"`
	Streams     []*Streams          `json:"streams"`
	// When is the team creation deadline
	TeamCreationClosesAt *string `json:"teamCreationClosesAt"`
	// Paginated, queryable list of teams
	Teams *TeamConnection `json:"teams"`
	// The timezone of the tournament
	Timezone *string `json:"timezone"`
	// The type of tournament from TournamentType
	TournamentType *int `json:"tournamentType"`
	// When the tournament was last modified (unix timestamp)
	UpdatedAt *string `json:"updatedAt"`
	// Build Tournament URL
	URL          *string `json:"url"`
	VenueAddress *string `json:"venueAddress"`
	VenueName    *string `json:"venueName"`
	// List of all waves in this tournament
	Waves []*Wave `json:"waves"`
}

func (Tournament) IsStandingContainer() {}

type TournamentConnection struct {
	PageInfo *PageInfo     `json:"pageInfo"`
	Nodes    []*Tournament `json:"nodes"`
}

type TournamentLinks struct {
	Facebook *string `json:"facebook"`
	Discord  *string `json:"discord"`
}

type TournamentLocationFilter struct {
	// Latitude, Longitude
	DistanceFrom *string `json:"distanceFrom"`
	// e.g. 50mi
	Distance *string `json:"distance"`
}

type TournamentPageFilter struct {
	ID  *string   `json:"id"`
	Ids []*string `json:"ids"`
	// ID of the user that owns this tournament.
	OwnerID           *string                   `json:"ownerId"`
	CountryCode       *string                   `json:"countryCode"`
	AddrState         *string                   `json:"addrState"`
	Location          *TournamentLocationFilter `json:"location"`
	AfterDate         *string                   `json:"afterDate"`
	BeforeDate        *string                   `json:"beforeDate"`
	ComputedUpdatedAt *string                   `json:"computedUpdatedAt"`
	Name              *string                   `json:"name"`
	VenueName         *string                   `json:"venueName"`
	IsFeatured        *bool                     `json:"isFeatured"`
	IsLeague          *bool                     `json:"isLeague"`
	HasBannerImages   *bool                     `json:"hasBannerImages"`
	ActiveShops       *bool                     `json:"activeShops"`
	RegOpen           *bool                     `json:"regOpen"`
	Past              *bool                     `json:"past"`
	Published         *bool                     `json:"published"`
	StaffPicks        *bool                     `json:"staffPicks"`
	HasOnlineEvents   *bool                     `json:"hasOnlineEvents"`
	TopGames          *TopGameFilter            `json:"topGames"`
	Upcoming          *bool                     `json:"upcoming"`
	VideogameIds      []*string                 `json:"videogameIds"`
}

type TournamentQuery struct {
	Page    *int                      `json:"page"`
	PerPage *int                      `json:"perPage"`
	SortBy  *string                   `json:"sortBy"`
	Filter  *TournamentPageFilter     `json:"filter"`
	Sort    *TournamentPaginationSort `json:"sort"`
}

type UpdatePhaseSeedInfo struct {
	SeedID       string  `json:"seedId"`
	SeedNum      string  `json:"seedNum"`
	PhaseGroupID *string `json:"phaseGroupId"`
}

type UpdatePhaseSeedingOptions struct {
	// Validate that seedMapping exactly accounts for all entrants in the phase
	StrictMode *bool `json:"strictMode"`
}

// A user
type User struct {
	ID *string `json:"id"`
	// Authorizations to external services (i.e. Twitch, Twitter)
	Authorizations []*ProfileAuthorization `json:"authorizations"`
	Bio            *string                 `json:"bio"`
	// Public facing user birthday that respects user publishing settings
	Birthday *string `json:"birthday"`
	// Events this user has competed in
	Events        *EventConnection `json:"events"`
	GenderPronoun *string          `json:"genderPronoun"`
	Images        []*Image         `json:"images"`
	// Leagues this user has competed in
	Leagues *LeagueConnection `json:"leagues"`
	// Public location info for this user
	Location *Address `json:"location"`
	// Public facing user name that respects user publishing settings
	Name *string `json:"name"`
	// player for user
	Player *Player `json:"player"`
	Slug   *string `json:"slug"`
	// Tournaments this user is organizing or competing in
	Tournaments *TournamentConnection `json:"tournaments"`
}

type UserEventsPaginationFilter struct {
	VideogameID     []*string             `json:"videogameId"`
	EventType       *int                  `json:"eventType"`
	MinEntrantCount *int                  `json:"minEntrantCount"`
	MaxEntrantCount *int                  `json:"maxEntrantCount"`
	Location        *LocationFilterType   `json:"location"`
	Search          *PaginationSearchType `json:"search"`
}

type UserEventsPaginationQuery struct {
	Page    *int                        `json:"page"`
	PerPage *int                        `json:"perPage"`
	SortBy  *string                     `json:"sortBy"`
	Filter  *UserEventsPaginationFilter `json:"filter"`
}

type UserLeaguesPaginationFilter struct {
	VideogameID []*string             `json:"videogameId"`
	Upcoming    *bool                 `json:"upcoming"`
	Past        *bool                 `json:"past"`
	Search      *PaginationSearchType `json:"search"`
}

type UserLeaguesPaginationQuery struct {
	Page    *int                         `json:"page"`
	PerPage *int                         `json:"perPage"`
	SortBy  *string                      `json:"sortBy"`
	Filter  *UserLeaguesPaginationFilter `json:"filter"`
}

type UserTournamentsPaginationFilter struct {
	Past           *bool                 `json:"past"`
	Upcoming       *bool                 `json:"upcoming"`
	Search         *PaginationSearchType `json:"search"`
	VideogameID    []*string             `json:"videogameId"`
	TournamentView *string               `json:"tournamentView"`
}

type UserTournamentsPaginationQuery struct {
	Page    *int                             `json:"page"`
	PerPage *int                             `json:"perPage"`
	SortBy  *string                          `json:"sortBy"`
	Filter  *UserTournamentsPaginationFilter `json:"filter"`
}

// A videogame
type Videogame struct {
	ID          *string  `json:"id"`
	DisplayName *string  `json:"displayName"`
	Images      []*Image `json:"images"`
	Name        *string  `json:"name"`
	Slug        *string  `json:"slug"`
}

type VideogameConnection struct {
	PageInfo *PageInfo    `json:"pageInfo"`
	Nodes    []*Videogame `json:"nodes"`
}

type VideogamePageFilter struct {
	ID      []*string `json:"id"`
	Name    *string   `json:"name"`
	ForUser *string   `json:"forUser"`
}

type VideogameQuery struct {
	Page    *int                 `json:"page"`
	PerPage *int                 `json:"perPage"`
	SortBy  *string              `json:"sortBy"`
	Filter  *VideogamePageFilter `json:"filter"`
}

// A wave in a tournament
type Wave struct {
	ID *string `json:"id"`
	// The Wave Identifier
	Identifier *string `json:"identifier"`
	// Unix time the wave is scheduled to start.
	StartAt *string `json:"startAt"`
}

type WaveUpsertInput struct {
	Identifier string `json:"identifier"`
	StartAt    string `json:"startAt"`
	EndAt      string `json:"endAt"`
}

// Represents the state of an activity
type ActivityState string

const (
	// Activity is created
	ActivityStateCreated ActivityState = "CREATED"
	// Activity is active or in progress
	ActivityStateActive ActivityState = "ACTIVE"
	// Activity is done
	ActivityStateCompleted ActivityState = "COMPLETED"
	// Activity is ready to be started
	ActivityStateReady ActivityState = "READY"
	// Activity is invalid
	ActivityStateInvalid ActivityState = "INVALID"
	// Activity, like a set, has been called to start
	ActivityStateCalled ActivityState = "CALLED"
	// Activity is queued to run
	ActivityStateQueued ActivityState = "QUEUED"
)

var AllActivityState = []ActivityState{
	ActivityStateCreated,
	ActivityStateActive,
	ActivityStateCompleted,
	ActivityStateReady,
	ActivityStateInvalid,
	ActivityStateCalled,
	ActivityStateQueued,
}

func (e ActivityState) IsValid() bool {
	switch e {
	case ActivityStateCreated, ActivityStateActive, ActivityStateCompleted, ActivityStateReady, ActivityStateInvalid, ActivityStateCalled, ActivityStateQueued:
		return true
	}
	return false
}

func (e ActivityState) String() string {
	return string(e)
}

func (e *ActivityState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActivityState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActivityState", str)
	}
	return nil
}

func (e ActivityState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the name of the third-party service (e.g Twitter) for OAuth
type AuthorizationType string

const (
	AuthorizationTypeTwitter AuthorizationType = "TWITTER"
	AuthorizationTypeTwitch  AuthorizationType = "TWITCH"
	AuthorizationTypeSteam   AuthorizationType = "STEAM"
	AuthorizationTypeDiscord AuthorizationType = "DISCORD"
	AuthorizationTypeMixer   AuthorizationType = "MIXER"
)

var AllAuthorizationType = []AuthorizationType{
	AuthorizationTypeTwitter,
	AuthorizationTypeTwitch,
	AuthorizationTypeSteam,
	AuthorizationTypeDiscord,
	AuthorizationTypeMixer,
}

func (e AuthorizationType) IsValid() bool {
	switch e {
	case AuthorizationTypeTwitter, AuthorizationTypeTwitch, AuthorizationTypeSteam, AuthorizationTypeDiscord, AuthorizationTypeMixer:
		return true
	}
	return false
}

func (e AuthorizationType) String() string {
	return string(e)
}

func (e *AuthorizationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthorizationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthorizationType", str)
	}
	return nil
}

func (e AuthorizationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of Bracket format that a Phase is configured with.
type BracketType string

const (
	BracketTypeSingleElimination BracketType = "SINGLE_ELIMINATION"
	BracketTypeDoubleElimination BracketType = "DOUBLE_ELIMINATION"
	BracketTypeRoundRobin        BracketType = "ROUND_ROBIN"
	BracketTypeSwiss             BracketType = "SWISS"
	BracketTypeExhibition        BracketType = "EXHIBITION"
	BracketTypeCustomSchedule    BracketType = "CUSTOM_SCHEDULE"
	BracketTypeMatchmaking       BracketType = "MATCHMAKING"
	BracketTypeEliminationRounds BracketType = "ELIMINATION_ROUNDS"
	BracketTypeRace              BracketType = "RACE"
)

var AllBracketType = []BracketType{
	BracketTypeSingleElimination,
	BracketTypeDoubleElimination,
	BracketTypeRoundRobin,
	BracketTypeSwiss,
	BracketTypeExhibition,
	BracketTypeCustomSchedule,
	BracketTypeMatchmaking,
	BracketTypeEliminationRounds,
	BracketTypeRace,
}

func (e BracketType) IsValid() bool {
	switch e {
	case BracketTypeSingleElimination, BracketTypeDoubleElimination, BracketTypeRoundRobin, BracketTypeSwiss, BracketTypeExhibition, BracketTypeCustomSchedule, BracketTypeMatchmaking, BracketTypeEliminationRounds, BracketTypeRace:
		return true
	}
	return false
}

func (e BracketType) String() string {
	return string(e)
}

func (e *BracketType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BracketType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BracketType", str)
	}
	return nil
}

func (e BracketType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Comparison operator
type Comparator string

const (
	ComparatorGreaterThan        Comparator = "GREATER_THAN"
	ComparatorGreaterThanOrEqual Comparator = "GREATER_THAN_OR_EQUAL"
	ComparatorEqual              Comparator = "EQUAL"
	ComparatorLessThanOrEqual    Comparator = "LESS_THAN_OR_EQUAL"
	ComparatorLessThan           Comparator = "LESS_THAN"
)

var AllComparator = []Comparator{
	ComparatorGreaterThan,
	ComparatorGreaterThanOrEqual,
	ComparatorEqual,
	ComparatorLessThanOrEqual,
	ComparatorLessThan,
}

func (e Comparator) IsValid() bool {
	switch e {
	case ComparatorGreaterThan, ComparatorGreaterThanOrEqual, ComparatorEqual, ComparatorLessThanOrEqual, ComparatorLessThan:
		return true
	}
	return false
}

func (e Comparator) String() string {
	return string(e)
}

func (e *Comparator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Comparator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Comparator", str)
	}
	return nil
}

func (e Comparator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of selection i.e. is it for a character or something else
type GameSelectionType string

const (
	// Character selection
	GameSelectionTypeCharacter GameSelectionType = "CHARACTER"
)

var AllGameSelectionType = []GameSelectionType{
	GameSelectionTypeCharacter,
}

func (e GameSelectionType) IsValid() bool {
	switch e {
	case GameSelectionTypeCharacter:
		return true
	}
	return false
}

func (e GameSelectionType) String() string {
	return string(e)
}

func (e *GameSelectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameSelectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameSelectionType", str)
	}
	return nil
}

func (e GameSelectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different options available for verifying player-reported match results
type MatchConfigVerificationMethod string

const (
	MatchConfigVerificationMethodTwitch   MatchConfigVerificationMethod = "TWITCH"
	MatchConfigVerificationMethodStreamMe MatchConfigVerificationMethod = "STREAM_ME"
	MatchConfigVerificationMethodAny      MatchConfigVerificationMethod = "ANY"
	MatchConfigVerificationMethodMixer    MatchConfigVerificationMethod = "MIXER"
	MatchConfigVerificationMethodYoutube  MatchConfigVerificationMethod = "YOUTUBE"
)

var AllMatchConfigVerificationMethod = []MatchConfigVerificationMethod{
	MatchConfigVerificationMethodTwitch,
	MatchConfigVerificationMethodStreamMe,
	MatchConfigVerificationMethodAny,
	MatchConfigVerificationMethodMixer,
	MatchConfigVerificationMethodYoutube,
}

func (e MatchConfigVerificationMethod) IsValid() bool {
	switch e {
	case MatchConfigVerificationMethodTwitch, MatchConfigVerificationMethodStreamMe, MatchConfigVerificationMethodAny, MatchConfigVerificationMethodMixer, MatchConfigVerificationMethodYoutube:
		return true
	}
	return false
}

func (e MatchConfigVerificationMethod) String() string {
	return string(e)
}

func (e *MatchConfigVerificationMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchConfigVerificationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchConfigVerificationMethod", str)
	}
	return nil
}

func (e MatchConfigVerificationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enforces limits on the amount of allowable Race submissions
type RaceLimitMode string

const (
	RaceLimitModeBestAll  RaceLimitMode = "BEST_ALL"
	RaceLimitModeFirstAll RaceLimitMode = "FIRST_ALL"
	RaceLimitModePlaytime RaceLimitMode = "PLAYTIME"
)

var AllRaceLimitMode = []RaceLimitMode{
	RaceLimitModeBestAll,
	RaceLimitModeFirstAll,
	RaceLimitModePlaytime,
}

func (e RaceLimitMode) IsValid() bool {
	switch e {
	case RaceLimitModeBestAll, RaceLimitModeFirstAll, RaceLimitModePlaytime:
		return true
	}
	return false
}

func (e RaceLimitMode) String() string {
	return string(e)
}

func (e *RaceLimitMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RaceLimitMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RaceLimitMode", str)
	}
	return nil
}

func (e RaceLimitMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Race type
type RaceType string

const (
	RaceTypeGoals RaceType = "GOALS"
	RaceTypeTimed RaceType = "TIMED"
)

var AllRaceType = []RaceType{
	RaceTypeGoals,
	RaceTypeTimed,
}

func (e RaceType) IsValid() bool {
	switch e {
	case RaceTypeGoals, RaceTypeTimed:
		return true
	}
	return false
}

func (e RaceType) String() string {
	return string(e)
}

func (e *RaceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RaceType", str)
	}
	return nil
}

func (e RaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Different sort type configurations used when displaying multiple sets
type SetSortType string

const (
	// Sets will not be sorted.
	SetSortTypeNone SetSortType = "NONE"
	// Sets are sorted in the suggested order that they be called to be played. The order of completed sets is reversed.
	SetSortTypeCallOrder SetSortType = "CALL_ORDER"
	// Sets are sorted by relevancy dependent on the state and progress of the event.
	SetSortTypeMagic SetSortType = "MAGIC"
	// Sets are sorted in the order that they were started.
	SetSortTypeRecent SetSortType = "RECENT"
	// Deprecated. This is equivalent to CALL_ORDER
	SetSortTypeStandard SetSortType = "STANDARD"
)

var AllSetSortType = []SetSortType{
	SetSortTypeNone,
	SetSortTypeCallOrder,
	SetSortTypeMagic,
	SetSortTypeRecent,
	SetSortTypeStandard,
}

func (e SetSortType) IsValid() bool {
	switch e {
	case SetSortTypeNone, SetSortTypeCallOrder, SetSortTypeMagic, SetSortTypeRecent, SetSortTypeStandard:
		return true
	}
	return false
}

func (e SetSortType) String() string {
	return string(e)
}

func (e *SetSortType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SetSortType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SetSortType", str)
	}
	return nil
}

func (e SetSortType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the name of the third-party social service (e.g Twitter) for OAuth
type SocialConnectionType string

const (
	SocialConnectionTypeTwitter SocialConnectionType = "TWITTER"
	SocialConnectionTypeTwitch  SocialConnectionType = "TWITCH"
	SocialConnectionTypeDiscord SocialConnectionType = "DISCORD"
	SocialConnectionTypeMixer   SocialConnectionType = "MIXER"
)

var AllSocialConnectionType = []SocialConnectionType{
	SocialConnectionTypeTwitter,
	SocialConnectionTypeTwitch,
	SocialConnectionTypeDiscord,
	SocialConnectionTypeMixer,
}

func (e SocialConnectionType) IsValid() bool {
	switch e {
	case SocialConnectionTypeTwitter, SocialConnectionTypeTwitch, SocialConnectionTypeDiscord, SocialConnectionTypeMixer:
		return true
	}
	return false
}

func (e SocialConnectionType) String() string {
	return string(e)
}

func (e *SocialConnectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SocialConnectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SocialConnectionType", str)
	}
	return nil
}

func (e SocialConnectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the source of a stream
type StreamSource string

const (
	// Stream is on twitch.tv channel
	StreamSourceTwitch StreamSource = "TWITCH"
	// Stream is on smashcast.tv channel
	StreamSourceHitbox StreamSource = "HITBOX"
	// Stream is on a stream.me channel
	StreamSourceStreamme StreamSource = "STREAMME"
	// Stream is on a mixer.com channel
	StreamSourceMixer StreamSource = "MIXER"
)

var AllStreamSource = []StreamSource{
	StreamSourceTwitch,
	StreamSourceHitbox,
	StreamSourceStreamme,
	StreamSourceMixer,
}

func (e StreamSource) IsValid() bool {
	switch e {
	case StreamSourceTwitch, StreamSourceHitbox, StreamSourceStreamme, StreamSourceMixer:
		return true
	}
	return false
}

func (e StreamSource) String() string {
	return string(e)
}

func (e *StreamSource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamSource", str)
	}
	return nil
}

func (e StreamSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the type of stream service
type StreamType string

const (
	StreamTypeTwitch StreamType = "TWITCH"
	StreamTypeMixer  StreamType = "MIXER"
)

var AllStreamType = []StreamType{
	StreamTypeTwitch,
	StreamTypeMixer,
}

func (e StreamType) IsValid() bool {
	switch e {
	case StreamTypeTwitch, StreamTypeMixer:
		return true
	}
	return false
}

func (e StreamType) String() string {
	return string(e)
}

func (e *StreamType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamType", str)
	}
	return nil
}

func (e StreamType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TournamentPaginationSort string

const (
	TournamentPaginationSortStartAt                   TournamentPaginationSort = "startAt"
	TournamentPaginationSortEndAt                     TournamentPaginationSort = "endAt"
	TournamentPaginationSortEventRegistrationClosesAt TournamentPaginationSort = "eventRegistrationClosesAt"
	TournamentPaginationSortComputedUpdatedAt         TournamentPaginationSort = "computedUpdatedAt"
)

var AllTournamentPaginationSort = []TournamentPaginationSort{
	TournamentPaginationSortStartAt,
	TournamentPaginationSortEndAt,
	TournamentPaginationSortEventRegistrationClosesAt,
	TournamentPaginationSortComputedUpdatedAt,
}

func (e TournamentPaginationSort) IsValid() bool {
	switch e {
	case TournamentPaginationSortStartAt, TournamentPaginationSortEndAt, TournamentPaginationSortEventRegistrationClosesAt, TournamentPaginationSortComputedUpdatedAt:
		return true
	}
	return false
}

func (e TournamentPaginationSort) String() string {
	return string(e)
}

func (e *TournamentPaginationSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TournamentPaginationSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TournamentPaginationSort", str)
	}
	return nil
}

func (e TournamentPaginationSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
